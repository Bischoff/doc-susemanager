<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook50-profile.xsl" 
 type="text/xml"
 title="Profiling step"?>
<sect1 xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="s1-maintenance-custom-packages">
 <title>Uploading and Maintaining Custom Packages</title>

 <para>
  The mgrpush application allows you to serve custom packages associated
  with a private &susemgr; channel through the &susemgr; server. If
  you want the &susemgr; server to serve only official &sle; or
  &rhel; packages, you do not need to install <command>mgrpush</command>.
 </para>

 <para>
  All packages distributed through &susemgr; should have a digital
  signature. A digital signature is created with a unique private key and
  can be verified with the corresponding public key. After creating a
  package, the SRPM (Source RPM) and the RPM can be digitally signed with a
  GnuPG key. Before the package is installed, the public key is used to
  verify the package was signed by a trusted party and the package has not
  changed since it was signed.
 </para>

 <sect2 xml:id="s2-maintenance-custom-packages-gpg">
  <title>Generating a GnuPG Keypair</title>
  <para>
   A GnuPG keypair consists of the private and public keys. To generate a
   keypair, proceed as follows:
  </para>
  <procedure>
   <step>
    <para>
     Type the following command as &rootuser; on the shell prompt:
    </para>
<screen>
     gpg --gen-key
    </screen>
   </step>
   <step>
    <para>
     The command will prompt for key type. Choose option (2) DSA and
     ElGamal. This allows you to create a digital signature and
     encrypt/decrypt with two types of technologies.
    </para>
   </step>
   <step>
    <para>
     Choose the key size. The longer the key, the more resistant against
     attacks the messages are. Creating a key of at least 2048 bits in size
     is recommended.
    </para>
   </step>
   <step>
    <para>
     Next, specify how long the key needs to be valid. When choosing an
     expiration date, remember that anyone using the public key must also be
     informed of the expiration and supplied with a new public key. We
     recommended to not select an expiration date. If you do not specify an
     expiration date, you are asked to confirm that the key should not
     expire.
    </para>
   </step>
   <step>
    <para>
     In the next steps, provide a User-ID containing your name, your email
     address, and an optional comment. When finished, you are presented with
     a summary of the information you entered. Accept your choices and enter
     a passphrase.
    </para>
    <note>
     <para>
      A good passphrase is essential for optimal security in GnuPG. Mix your
      passphrase with uppercase and lowercase letters, use numbers or
      punctuation marks.
     </para>
    </note>
   </step>
   <step>
    <para>
     Once you enter and verify your passphrase, the keys are generated. A
     message will ask you to move the mouse or otherwise interact with the
     system to generate random data for the key. This part of the key
     generation process may take several minutes. When the activity on the
     screen ceases, your new keys are placed in the directory
     <systemitem>.gnupg</systemitem> in &rootuser;'s home directory. This
     is the default location for keys generated by the &rootuser; user.
    </para>
    <para>
     To list the &rootuser; keys, use the <command>gpg
     --list-keys</command> command.
    </para>
   </step>
   <step>
    <para>
     To retrieve the public key, use the command <command>gpg
     --list-keys</command> command. The public key is written to the file
     <filename>public_key.txt</filename>. This key must be deployed to all
     client systems that receive custom packages from &susemgr;.
     Techniques for deploying this key across an organization are covered in
     <xref linkend="ch-gpg-keys"/>
    </para>
   </step>
  </procedure>
 </sect2>

 <sect2 xml:id="s2-maintenance-custom-packages-sign">
  <title>Signing Custom Packages</title>
  <para>
   Before the <command>rpm</command> command can be used to sign packages,
   it needs to know the key to use. View the uid of your secret key:
  </para>
<screen>
   gpg --list-secret-keys | grep uid
   </screen>
  <para>
   Add the following lines to the <filename>~/.rpmmacros</filename>
  </para>
<screen>
    %_signature gpg 
    %_gpg_path /etc/rpm/.gpg 
    %_gpg_name <replaceable>secret_key_uid</replaceable> 
    %_gpgbin /usr/bin/gpg 
   </screen>
  <para>
   Replace <replaceable>secret_key_uid</replaceable> with exactly the output
   from the <command>gpg --list-secret-keys | grep uid</command> command.
  </para>
  <note>
   <para>
    RPMs can be signed during or after build. Determine if a package has
    already been signed with the command: <command>rpm -qip</command>
    <replaceable>filename.rpm</replaceable>.
   </para>
  </note>
  <para>
   If the RPM is already signed, check whether the signature is correct. If
   the existing signature is not correct, resign the package:
  </para>
<screen>
    rpm --resign <replaceable>filename.rpm</replaceable> 
   </screen>
  <para>
   If the RPM is not signed, sign it:
  </para>
<screen>
    rpm --addsign <replaceable>filename.rpm</replaceable> 
   </screen>
  <para>
   Check the value of the "Signature" tag to ensure that the RPM has been
   signed correctly:
  </para>
<screen>
    rpm -qip <replaceable>filename.rpm</replaceable> 
   </screen>
 </sect2>

 <sect2 xml:id="s2-maintenance-custom-packages-upload">
  <title>Uploading Custom Packages</title>
  <para>
   To use <command>mgrpush</command>, install the
   <systemitem class="resource">rhnpush</systemitem> package and its
   dependencies. This package is available to registered &susemgr; Server
   systems and is installed by running <command>zypper in rhnpush</command>.
  </para>
  <para>
   mgrpush uploads RPM header information to the &susemgr; server
   database and places the RPM in the &susemgr; server package
   repository.
<!-- Unlike the RHN Proxy Server's RHN Package Manager, RHN Push never distributes package information, even the headers, outside of the RHN Satellite Server database. -->
  </para>
  <para>
   When mgrpush is installed, a central configuration file is installed in
   <filename>/etc/sysconfig/rhn/rhnpushrc</filename>. This file contains
   default values for all the options, which are described in the mgrpush
   manual page (<command>man mgrpush</command>).
  </para>
  <para>
   Additionally, mgrpush looks for settings in the current directory
   (<filename>./.rhnpushrc</filename>) take precedent over those in the
   user's home directory (<filename>~/.rhnpushrc</filename>), which are used
   before those in the central configuration file
   (<filename>/etc/sysconfig/rhn/rhnpushrc</filename>). These distinct
   configuration files are useful in varying settings depending on the
   directory from which the mgrpush command is issued.
  </para>
  <para>
   For instance the current directory configuration file can be used to
   specify:
  </para>
  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     the software channel to be populated,
    </para>
   </listitem>
   <listitem>
    <para>
     the home directory configuration file to include the username to be
     invoked,
    </para>
   </listitem>
   <listitem>
    <para>
     the central configuration file to identify the server to receive the
     packages.
    </para>
   </listitem>
  </itemizedlist>
<!--
Table 6.2, “rhnpush options” contains all command line options for the rhnpush command:
Table 6.2. rhnpush options
Option 	Description
-v -\-verbose 	Increase verbosity, option can be used multiple times, that is, -vv, -vvv, and so forth.
-d, -\-dir DIRECTORY 	Process packages from this directory.
-c, -\-channel=CHANNEL_LABEL 	Specify the channel to receive packages. Note that this is required and is not the same as the channel's name. Multiple channels may be specified using multiple instances of -c (e.g. -c CHANNEL_ONE -c CHANNEL_TWO).
-n, -\-count N_HEADERS_PER_CALL 	Process this number of headers per call. Must be an integer. The default number is 25.
-l, -\-list 	List only the specified channels.
-r, -\-reldirRELATIVE_DIRECTORY 	Associate this relative directory with each file.
-o, -\-orgidORGANIZATION_ID 	Include your organization's ID number. Must be an integer.
-u , -\-username USERNAME 	Include the RHN username of the user that has administrative access to the specified channel. If not provided, rhnpush prompts for the username of a valid Channel Administrator. The username and password are cached in ~/.rhnpushcache for a limited time, five minutes being the default. Use -\-new-cache to force a new username and password.
-p , -\-password PASSWORD 	Include RHN password of user that has administrative access to the specified channel. If not provided, rhnpush prompts for the password of a valid Channel Administrator. The username and password are cached in ~/.rhnpushcache for a limited time, five minutes being the default. Use -\-new-cache to force a new username and password.
-s, -\-stdin 	Read package list from standard input, for example from a piped ls command.
-X, -\-exclude GLOB 	Exclude packages that match this glob expression.
-\-force 	Force upload of a package, even if a package of that name and version currently exists in the channel. Without this option, uploading a pre-existing package returns an error.
-\-nosig 	Don't fail if packages are unsigned.
-\-new-cache 	Forces RHN Push to drop the username and password cache, then accept or ask for new ones. This is useful if you make a mistake entering them the first time.
-\-newest 	Push only the packages that are newer than those on the server. Note that source packages are special in that their versions are never compared to each other. Their newness is dependent on their associated binary packages. Using this option with RHN Push and just a source package does upload the package, but the source package does not appear in the RHN Web interface until the associated binary package has been uploaded. Contrast this with -\-source. Using -\-source -\-newest together does update the stand-alone source package with newer packages and does not require an associated binary package to be uploaded first.
-\-header 	Upload only the headers.
-\-source 	Upload the indicated source packages. Doing this treats them as plain, stand-alone packages and not as special source packages associated with another, pre-existing binary package. For example, you can use this when you want to distribute application source to developers and testers outside of regular source control management.
-\-server SERVER 	Specify the server to which packages are uploaded. Currently, a value of http://localhost/APP is necessary. This parameter is required.
-\-test 	Only print a list of the packages to be pushed, don't actually push them.
-h, -\-help 	Briefly describe the options.
-?, -\-usage 	View the usage summary.
-->
<!--
Tip
These command line options are also described in the rhnpush manual page: man rhnpush.
-->
 </sect2>
</sect1>
